# Introduction

This is a self made framework for a REST API. WIP, it still misses a lot of implementation like Authentication, support for rare HTTP method, proper routing, etc...

Every request are redirected to [index.php](https://github.com/MikaBob/parking-system/tree/main/src/index.php), the entrypoint (see .htaccess).

We will go into details, but in a nutshell we have the following process:

- Load libraries & php files
- Router parse request & instanciate the proper controller
- Controller will handle the request
    - authenticate if necessary
    - use a ORM to fetch or process data in the database
    - prepare and serialise its response
- Output the response

# Autoloader

The first autoloader is generated by composer to load the vendor libraries.

The second one is use by php, upon the keyword `use ParkingSystem\Folder\Class;`.

```php
spl_autoload_register(function ($fullQualifiedClassName) {
    $parts = explode('\\', $fullQualifiedClassName);
    // Replace first folder from namespace with the actual folder
    unset($parts[0]);
    $classPath = implode("/", $parts);

    $filePath = __DIR__ . "/$classPath.php";
    if(file_exists($filePath)){
        // concat proper fodler (/src)
        include_once $filePath;
    }
});
```

It will also validate and load the .env file.

# Router

The Router handle every request. It firstly parse the requested URL and method to a format of `/Controller/Action/param1/param2/...` . If the request has a body, it will be decoded and parsed as a JSON.

From these info, it will look for an associated controller. If the Controller and his action exist, the router will print the controller's response.

Example of Request `GET /fee/byplate/abcd/1234` will be parsed into `FeeController::GETbyplate(["abcd","1234"])`

```php
$request = self::parseRequest();
if (!empty($request)) {

    $fullQualifiedClassName = self::getControllerFullQualifiedName($request->getController());

    // class_exists()  will call the autoloader if class not already loaded.
    if (class_exists($fullQualifiedClassName, true)) {
        if (method_exists($fullQualifiedClassName, $request->getAction())) {
            
            $controller = new $fullQualifiedClassName();
            echo call_user_func([$controller, $request->getAction()], $request);
            return;
        } 
    }
}
```

# Controller

Controller will validate a request, do his action and return a response. To parse a request, there is a "Factory pattern" to specialize a request from the Request mother class to a child request class (From `Request` to `RequestFeeByPlate`).

```php 
public function GETbyzoneandplate(Request $request) : string {
    $request = RequestFactory::build(RequestFeeByZoneAndPlate::class, $request);

    if(!$request->getZone() || !$request->getPlate()) {
        return (new ResponseBadRequest())->toJSON();
    }

    /* some action here*/
}
```

A controller action typically is to fetch data, make sure the data are valid / expected and reply accordingly.

```php 
public function GETbyzoneandplate(Request $request) : string {
    
    /* some request parsing here */

    $validFees = $this->getRepository()->getFeesForZoneAndPlate(
        $request->getZone(),
        $request->getPlate()
    );
    
    if(!empty($validFees)){

        $latestValidFee = $validFees[0];
        return (new Response(200, [
            "valid" => true,
            "valid_until" => $latestValidFee->getDateEndValidity()->format('c'),
            "vehicule_plate" => $latestValidFee->getVehiculePlate(),
            "zone" =>  $latestValidFee->getParkingMeter()->getZone()->getZoneName()
        ]))->toJSON();
    }
    /* handle of exception / invalid data here */
}
```

# Model

## Entity

We are using Doctrine as ORM. We have entities that represent a row in a table. Each properties are typed, and relation are explicit.

```php

#[ORM\Entity]
#[ORM\Table(name: 'zone')]
class ZoneEntity implements \JsonSerializable {

    #[ORM\Id]
    #[ORM\GeneratedValue]
    #[ORM\Column(type: 'integer')]
    private int|null $id = null;

    #[ORM\Column(type: 'integer')]
    private int $hourly_fee;

    #[ORM\Column(type: 'integer')]
    private int $daily_fee;

    #[ORM\Column(type: 'string', enumType: ZoneEnum::class)]
    private ZoneEnum $zone_name;

    public function jsonSerialize(): mixed {
        return [
            'id' => $this->getId(),
            'hourly_fee' => $this->getHourlyFee(),
            'daily_fee' => $this->getDailyFee(),
            'zone_name' => $this->getZoneName(),
        ];
    }

    /* some getters / setters here */
```

## Repository

A repository will handle special queries to the Database, or better queries when the ORM's generic ones are unoptimised

```php
class FeeRepository extends AbstractEntityRepository {

    public function getFeesForZoneAndPlate(string $zone, string $plate) : array {
        $em = $this->getEntityManager();

        $queryBuilder= $em->createQueryBuilder('f');
        $queryBuilder
            ->select('f')
            ->from(FeeEntity::class, 'f')
            ->innerJoin('f.parking_meter', 'pm')
            ->andWhere('f.date_end_validity > :current_time')
            ->andWhere('f.zone_name = :zone')
            ->andWhere('f.vehicule_plate = :plate')
            ->orderBy('f.date_end_validity', 'DESC') // if we have several valid fees, get the latest valid first
        ;

        $query = $em->createQuery($queryBuilder->getDQL());
        $query->setParameter('plate', $plate);
        $query->setParameter('zone', $zone);
        $query->setParameter('current_time', new \DateTime());
        //var_dump($query->getSQL());

        return $query->getResult();
    }
}
```

## DbConnection

A singleton connection to the DB but the class isn't. The logic is that you actually can have several connection to the DB, but not multiple per object :)